; Vaisto Self-Hosted Parser
; Transforms token stream into AST
;
; The parser is a recursive descent parser that handles:
; - Parentheses: ( ... ) → function calls and special forms
; - Brackets: [ ... ] → vectors, let bindings, match patterns
; - Braces: { ... } → Erlang tuples (patterns)
; - Map literals: #{ ... } → maps

(ns Vaisto.Parser)

(import Vaisto.Lexer.Types)
(import Vaisto.Parser.AST)

; Erlang primitives
(extern lists/reverse [(List :any)] (List :any))
(extern lists/append [(List :any) (List :any)] (List :any))
(extern erlang/hd [(List :any)] :any)
(extern erlang/tl [(List :any)] (List :any))
(extern erlang/element [:int :any] :any)
(extern erlang/binary_to_atom [:string :any] :any)
(extern erlang/error [:any] :any)

; --- Main Entry Point ---

; Parse a list of tokens into a list of AST nodes
(defn parse [tokens]
  (parse-top-level tokens (list)))

(defn parse-top-level [tokens acc]
  (match tokens
    ; End of input
    [[] (lists/reverse acc)]
    [[{:EOF _}] (lists/reverse acc)]

    ; Parse one expression, continue with rest
    [_
      (match (parse-expr tokens)
        [{rest ast}
          (parse-top-level rest (cons ast acc))])]))

; --- Expression Parser ---
; Returns {remaining-tokens, ast}

(defn parse-expr [tokens]
  (match tokens
    ; Parenthesis: ( ... ) → call or special form
    [[{:LParen loc} | rest]
      (parse-delimited rest (list) :RParen loc :list)]

    ; Bracket: [ ... ] → vector/binding list
    [[{:LBracket loc} | rest]
      (parse-delimited rest (list) :RBracket loc :bracket)]

    ; Brace: { ... } → tuple pattern
    [[{:LBrace loc} | rest]
      (parse-delimited rest (list) :RBrace loc :brace)]

    ; Keywords: :foo → {:atom :foo}
    [[{:Keyword loc name} | rest]
      {rest (Vaisto.Parser.AST/keyword-node (string-to-atom name))}]

    ; Symbols: foo → :foo (atom)
    [[{:Symbol loc name} | rest]
      {rest (string-to-atom name)}]

    ; Integer literal
    [[{:IntLit loc val} | rest]
      {rest val}]

    ; Float literal
    [[{:FloatLit loc val} | rest]
      {rest val}]

    ; String literal
    [[{:StringLit loc val} | rest]
      {rest {:string val}}]

    ; Character literal
    [[{:CharLit loc val} | rest]
      {rest {:char val}}]

    ; Special form keywords (parsed as atoms by lexer)
    [[{:KwDef loc} | rest] {rest :def}]
    [[{:KwDefn loc} | rest] {rest :defn}]
    [[{:KwDeftype loc} | rest] {rest :deftype}]
    [[{:KwDefrecord loc} | rest] {rest :defrecord}]
    [[{:KwLet loc} | rest] {rest :let}]
    [[{:KwIf loc} | rest] {rest :if}]
    [[{:KwCond loc} | rest] {rest :cond}]
    [[{:KwMatch loc} | rest] {rest :match}]
    [[{:KwFn loc} | rest] {rest :fn}]
    [[{:KwDo loc} | rest] {rest :do}]
    [[{:KwNs loc} | rest] {rest :ns}]
    [[{:KwImport loc} | rest] {rest :import}]
    [[{:KwExtern loc} | rest] {rest :extern}]

    ; Unexpected token
    [[tok | rest]
      (erlang/error {:unexpected-token tok})]))

; --- Delimited Parser ---
; Parses until closing delimiter, returns {remaining, ast}

(defn parse-delimited [tokens acc closer loc kind]
  (match tokens
    ; Empty input - error
    [[] (erlang/error {:unclosed-delimiter kind loc})]

    ; Check for closing delimiter
    [[tok | rest]
      (if (is-closer? tok closer)
        (let [items (lists/reverse acc)]
          {rest (finalize-delimited items loc kind)})
        ; Not a closer - parse as expression
        (match (parse-expr tokens)
          [{remaining item}
            (parse-delimited remaining (cons item acc) closer loc kind)]))]))

; Finalize based on delimiter type
(defn finalize-delimited [items loc kind]
  (match kind
    [:list (analyze-list items loc)]
    [:bracket {:bracket items}]
    [:brace {:tuple_pattern items}]))

; --- Special Form Analysis ---
; Takes a list of items and creates the appropriate AST node

(defn analyze-list [items loc]
  (match items
    ; Empty: () → unit
    [[] (Vaisto.Parser.AST/unit-node loc)]

    ; --- Special Forms ---

    ; (ns ModuleName)
    [[:ns name] (Vaisto.Parser.AST/ns-node name loc)]

    ; (import Module) or (import Module Alias)
    [[:import module] (Vaisto.Parser.AST/import-node module :none loc)]
    [[:import module alias] (Vaisto.Parser.AST/import-node module alias loc)]

    ; (defn name [params] body) or (defn name [params] :type body)
    [[:defn name {:bracket params} | rest]
      (parse-defn-body name params rest loc)]

    ; (defn name [[pat1] body1] [[pat2] body2]) - multi-clause
    [[:defn name | clauses]
      (Vaisto.Parser.AST/defn-multi-node name (parse-clauses clauses) loc)]

    ; (def name value)
    [[:def name value] (Vaisto.Parser.AST/def-node name value loc)]

    ; (deftype Name [field :type ...]) - record
    [[:deftype name {:bracket fields}]
      (Vaisto.Parser.AST/deftype-record-node name fields loc)]

    ; (deftype Name (Ctor1 a) (Ctor2 b c)) - sum type
    [[:deftype name | variants]
      (Vaisto.Parser.AST/deftype-sum-node name variants loc)]

    ; (fn [params] body)
    [[:fn {:bracket params} | body]
      (Vaisto.Parser.AST/fn-node params (block-body body loc) loc)]

    ; (let [bindings] body)
    [[:let {:bracket bindings} | body]
      (Vaisto.Parser.AST/let-node (parse-bindings bindings) (block-body body loc) loc)]

    ; (if cond then else)
    [[:if cond then else]
      (Vaisto.Parser.AST/if-node cond then else loc)]

    ; (cond [test1 body1] [test2 body2] ...)
    [[:cond | clauses]
      (Vaisto.Parser.AST/cond-node (parse-clauses clauses) loc)]

    ; (match expr [pat1 body1] [pat2 body2] ...)
    [[:match expr | clauses]
      (Vaisto.Parser.AST/match-node expr (parse-clauses clauses) loc)]

    ; (do expr1 expr2 ...)
    [[:do | exprs]
      (Vaisto.Parser.AST/do-node exprs loc)]

    ; (extern mod/func [arg-types] ret-type)
    [[:extern qualified-name {:bracket arg-types} ret-type]
      (parse-extern qualified-name arg-types ret-type loc)]

    ; (. record :field) - field access
    [[:. record field]
      (Vaisto.Parser.AST/field-access-node record field loc)]

    ; (-> x (f a) (g b)) - threading macro
    [[:-> | forms]
      (expand-thread-first forms)]

    ; (list a b c) - explicit list
    [[:list | elements]
      (Vaisto.Parser.AST/list-node elements loc)]

    ; (tuple a b c) - explicit tuple
    [[:tuple | elements]
      (Vaisto.Parser.AST/tuple-node elements loc)]

    ; Default: function call
    [[func | args]
      (Vaisto.Parser.AST/call-node func args loc)]))

; --- Helper Functions ---

; Parse defn body - handles optional return type
(defn parse-defn-body [name params rest loc]
  (match rest
    ; With return type annotation: (defn foo [x] :int body)
    [[{:atom type} | body]
      (Vaisto.Parser.AST/defn-node name params (block-body body loc) type loc)]
    ; Check if first is a keyword atom
    [[type | body]
      (if (keyword? type)
        (Vaisto.Parser.AST/defn-node name params (block-body body loc) type loc)
        (Vaisto.Parser.AST/defn-node name params (block-body rest loc) :any loc))]
    ; No return type
    [body
      (Vaisto.Parser.AST/defn-node name params (block-body body loc) :any loc)]))

; Wrap multiple body expressions in (do ...) if needed
(defn block-body [exprs loc]
  (match exprs
    [[single] single]
    [_ (Vaisto.Parser.AST/do-node exprs loc)]))

; Parse let bindings: [x 1 y 2] → [{x 1} {y 2}]
(defn parse-bindings [items]
  (parse-bindings-acc items (list)))

(defn parse-bindings-acc [items acc]
  (match items
    [[] (lists/reverse acc)]
    [[name value | rest]
      (parse-bindings-acc rest (cons {name value} acc))]))

; Parse match/cond clauses: [{:bracket [pat body]}] → [{pat body}]
(defn parse-clauses [clauses]
  (lists/map parse-clause clauses))

(defn parse-clause [clause]
  (match clause
    [{:bracket [pattern | body]}
      {pattern (block-body body {:line 0 :col 0})}]
    [_ clause]))  ; Already parsed or different format

; Parse extern: mod/func → {mod func}
(defn parse-extern [qualified arg-types ret-type loc]
  (match qualified
    ; Symbol like erlang/hd
    [sym
      (let [parts (split-qualified sym)]
        (Vaisto.Parser.AST/extern-node
          (tuple-elem parts 0)
          (tuple-elem parts 1)
          arg-types
          ret-type
          loc))]))

; Split qualified name: erlang/hd → {erlang hd}
(extern binary/split [:string :string :any] (List :any))
(defn split-qualified [sym]
  (let [str (atom-to-string sym)
        parts (binary/split str "/" [:global])]
    (match parts
      [[mod func] {(string-to-atom mod) (string-to-atom func)}]
      [_ {sym sym}])))

; Threading macro expansion: (-> x (f a) (g)) → (g (f x a))
(defn expand-thread-first [forms]
  (match forms
    [[initial] initial]
    [[initial | rest]
      (lists/foldl thread-into initial rest)]))

(defn thread-into [acc form]
  (match form
    ; (f arg1 arg2) → (f acc arg1 arg2)
    [{:call func args loc}
      {:call func (cons acc args) loc}]
    ; Bare symbol f → (f acc)
    [func
      {:call func (list acc) {:line 0 :col 0}}]))

; --- Utility Functions ---

; Check if token is a specific closing delimiter
(defn is-closer? [tok closer]
  (match tok
    [{:RParen _} (== closer :RParen)]
    [{:RBracket _} (== closer :RBracket)]
    [{:RBrace _} (== closer :RBrace)]
    [_ false]))

(defn string-to-atom [s]
  (erlang/binary_to_atom s :utf8))

(extern erlang/atom_to_binary [:any :any] :string)
(defn atom-to-string [a]
  (erlang/atom_to_binary a :utf8))

(defn tuple-elem [t i]
  (erlang/element (+ i 1) t))

(defn keyword? [x]
  (match x
    [{:atom _} true]
    [_ false]))

(extern lists/map [:any (List :any)] (List :any))
