; Vaisto Type Checker - Error Constructors
; Creates structured error values for type checking failures
;
; All errors include enough information for helpful diagnostics:
; - Error message
; - Expected vs actual types
; - Hints for fixing

(ns Vaisto.TypeChecker.Errors)

(import Vaisto.TypeChecker.Types)

; Erlang FFI
(extern erlang/iolist_to_binary [(List :any)] :string)
(extern erlang/atom_to_binary [:any] :string)
(extern erlang/integer_to_binary [:int] :string)
(extern lists/map [:any (List :any)] (List :any))

; --- Error Record ---
; Structured error with all diagnostic info as a map

(defn make-error [message]
  #{ :message message :expected :none :actual :none :note :none :hint :none :loc :none})

(extern maps/put [:any :any :any] :any)

(defn with-expected [err expected]
  (maps/put :expected expected err))

(defn with-actual [err actual]
  (maps/put :actual actual err))

(defn with-note [err note]
  (maps/put :note note err))

(defn with-hint [err hint]
  (maps/put :hint hint err))

(defn with-loc [err loc]
  (maps/put :loc loc err))

; --- Type Mismatch Errors ---

(defn type-mismatch [expected actual]
  (-> (make-error "type mismatch")
      (with-expected expected)
      (with-actual actual)))

(defn list-type-mismatch [expected actual]
  (-> (make-error "list elements must have the same type")
      (with-expected expected)
      (with-actual actual)))

(defn branch-type-mismatch [branch1 branch2]
  (-> (make-error "branch types must match")
      (with-expected branch1)
      (with-actual branch2)
      (with-note "all branches of a conditional must return the same type")))

(defn return-type-mismatch [declared inferred]
  (-> (make-error "return type mismatch")
      (with-expected declared)
      (with-actual inferred)
      (with-hint "the function body returns a different type than declared")))

; --- Arity Errors ---

(defn arity-mismatch [func-name expected actual]
  (-> (make-error "wrong number of arguments")
      (with-note (erlang/iolist_to_binary
                   (list "`" (erlang/atom_to_binary func-name) "` takes "
                         (erlang/integer_to_binary expected) " argument(s), but "
                         (erlang/integer_to_binary actual) " were provided")))))

(defn mapper-arity [operation expected actual]
  (-> (make-error (erlang/iolist_to_binary
                    (list (erlang/atom_to_binary operation) " function has wrong arity")))
      (with-note (erlang/iolist_to_binary
                   (list "`" (erlang/atom_to_binary operation) "` function must take exactly "
                         (erlang/integer_to_binary expected) " argument(s), got "
                         (erlang/integer_to_binary actual))))))

; --- List Operation Errors ---

(defn cons-type-mismatch [elem-type list-type]
  (-> (make-error "cons type mismatch")
      (with-expected list-type)
      (with-actual elem-type)
      (with-hint "element type must match list element type")))

(defn not-a-list [operation actual]
  (-> (make-error "expected a list")
      (with-expected {:list :any})
      (with-actual actual)
      (with-note (erlang/iolist_to_binary
                   (list "`" (erlang/atom_to_binary operation) "` operates on lists")))))

(defn not-a-function [operation actual]
  (-> (make-error "expected a function")
      (with-expected {:fn (list :any) :any})
      (with-actual actual)
      (with-note (erlang/iolist_to_binary
                   (list "`" (erlang/atom_to_binary operation) "` requires a function argument")))))

(defn predicate-not-bool [actual]
  (-> (make-error "predicate must return Bool")
      (with-expected :bool)
      (with-actual actual)
      (with-hint "filter predicates must return true or false")))

; --- Name Resolution Errors ---

(defn undefined-variable [name]
  (-> (make-error "undefined variable")
      (with-note (erlang/iolist_to_binary
                   (list "`" (erlang/atom_to_binary name) "` is not defined in this scope")))))

(defn unknown-function [name]
  (-> (make-error "unknown function")
      (with-note (erlang/iolist_to_binary
                   (list "`" (format-function-name name) "` is not defined")))))

; Format a function name (handles both atoms and {:qualified mod func})
(defn format-function-name [name]
  (match name
    [{:qualified mod func}
      (erlang/iolist_to_binary
        (list (erlang/atom_to_binary mod) "/" (erlang/atom_to_binary func)))]
    [_ (erlang/atom_to_binary name)]))

(defn unknown-type [name]
  (-> (make-error "unknown type")
      (with-note (erlang/iolist_to_binary
                   (list "type `" (erlang/atom_to_binary name) "` is not defined")))))

(defn unknown-process [name]
  (-> (make-error "unknown process")
      (with-note (erlang/iolist_to_binary
                   (list "process `" (erlang/atom_to_binary name) "` is not defined in this module")))))

; --- Process/Concurrency Errors ---

(defn invalid-message [process-name message accepted]
  (let [accepted-str (format-accepted-messages accepted)]
    (-> (make-error "invalid message type")
        (with-note (erlang/iolist_to_binary
                     (list "process `" (erlang/atom_to_binary process-name)
                           "` does not accept `:" (erlang/atom_to_binary message) "`")))
        (with-hint (erlang/iolist_to_binary
                     (list "accepted messages: " accepted-str))))))

(defn format-accepted-messages [accepted]
  (erlang/iolist_to_binary
    (intersperse ", "
      (lists/map (fn [msg] (erlang/iolist_to_binary (list ":" (erlang/atom_to_binary msg)))) accepted))))

(defn intersperse [sep lst]
  (match lst
    [[] (list)]
    [[x] (list x)]
    [[x | rest] (cons x (cons sep (intersperse sep rest)))]))

(defn send-to-non-pid [actual]
  (-> (make-error "cannot send to non-pid")
      (with-actual actual)
      (with-note "the `!` operator requires a PID as the first argument")))

; --- Unification Errors ---

(defn infinite-type [tvar-id t]
  ; Format with context so the tvar shows as 'a not t452
  (let [tvar {:tvar tvar-id}
        ctx (Vaisto.TypeChecker.Types/build-display-ctx (list tvar t))
        tvar-str (Vaisto.TypeChecker.Types/format-type-with-ctx tvar ctx)
        type-str (Vaisto.TypeChecker.Types/format-type-with-ctx t ctx)]
    (-> (make-error "infinite type")
        (with-note (erlang/iolist_to_binary
                     (list tvar-str " cannot contain itself (found in " type-str ")")))
        (with-hint "this usually means a recursive type without a base case"))))

(defn cannot-unify [t1 t2]
  (-> (make-error "cannot unify types")
      (with-expected t1)
      (with-actual t2)))

; --- Error Formatting ---
; Uses contextual normalization so type variables display as 'a, 'b
; instead of raw IDs like t452, t890

(defn format-optional [label value formatter]
  (if (== value :none)
    ""
    (erlang/iolist_to_binary (list label (formatter value)))))

(defn format-optional-with-ctx [label value ctx]
  (if (== value :none)
    ""
    (erlang/iolist_to_binary
      (list label (Vaisto.TypeChecker.Types/format-type-with-ctx value ctx)))))

(defn identity [x] x)

; Main error formatter - uses contextual type variable normalization
(defn format-error [err]
  (let [msg (. err :message)
        expected (. err :expected)
        actual (. err :actual)
        note (. err :note)
        hint (. err :hint)
        ; Build context from both types so 'a, 'b are consistent
        types-to-normalize (collect-types-from-error expected actual)
        ctx (Vaisto.TypeChecker.Types/build-display-ctx types-to-normalize)]
    (erlang/iolist_to_binary
      (list
        "error: " msg
        (format-optional-with-ctx "\n  expected: " expected ctx)
        (format-optional-with-ctx "\n  actual: " actual ctx)
        (format-optional "\n  note: " note identity)
        (format-optional "\n  hint: " hint identity)))))

; Collect types that need normalization (skip :none values)
(defn collect-types-from-error [expected actual]
  (match {expected actual}
    [{:none :none} (list)]
    [{:none a} (list a)]
    [{e :none} (list e)]
    [{e a} (list e a)]))
