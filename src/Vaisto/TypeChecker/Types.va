; Vaisto Type Checker - Type Representation
; ADT definitions for the type system
;
; This module defines how types are represented internally.
; Uses sum types (ADTs) for type-safe pattern matching.

(ns Vaisto.TypeChecker.Types)

(import Std.String)

; Erlang FFI
(extern erlang/iolist_to_binary [(List :any)] :string)
(extern erlang/integer_to_binary [:int] :string)
(extern erlang/atom_to_binary [:any] :string)
(extern lists/append [(List :any) (List :any)] (List :any))
(extern lists/reverse [(List :any)] (List :any))

; --- Type Variable ---
; Fresh type variables for inference: t0, t1, t2, ...
(defn tvar [id :int]
  {:tvar id})

; Row variable for row polymorphism: r0, r1, r2, ...
(defn rvar [id :int]
  {:rvar id})

; --- Type Representation ---
; Types are represented as tagged tuples (Erlang-style for interop)
;
; Primitive types: :int, :float, :bool, :string, :any, :unit
; Atom type: {:atom :foo}
; List type: {:list elem-type}
; Function type: {:fn [arg-types] ret-type}
; Record type: {:record Name [{:field-name type} ...]}
; Sum type: {:sum Name [{:ctor-name [field-types]} ...]}
; Type variable: {:tvar id}
; Row variable: {:rvar id}
; Row type: {:row [{:field type} ...] tail}
;   tail is either {:rvar id} (open) or :closed
; PID type: {:pid process-name accepted-messages}

; --- Type Predicates ---

(defn tvar? [t]
  (match t
    [{:tvar _} true]
    [_ false]))

(defn rvar? [t]
  (match t
    [{:rvar _} true]
    [_ false]))

(defn fn-type? [t]
  (match t
    [{:fn _ _} true]
    [_ false]))

(defn list-type? [t]
  (match t
    [{:list _} true]
    [_ false]))

(defn record-type? [t]
  (match t
    [{:record _ _} true]
    [_ false]))

(defn sum-type? [t]
  (match t
    [{:sum _ _} true]
    [_ false]))

(defn row-type? [t]
  (match t
    [{:row _ _} true]
    [_ false]))

; --- Type Constructors ---

(defn make-fn-type [arg-types ret-type]
  {:fn arg-types ret-type})

(defn make-list-type [elem-type]
  {:list elem-type})

(defn make-record-type [name fields]
  {:record name fields})

(defn make-sum-type [name variants]
  {:sum name variants})

(defn make-row-type [fields tail]
  {:row fields tail})

(defn make-atom-type [a]
  {:atom a})

(defn make-pid-type [process-name accepted-msgs]
  {:pid process-name accepted-msgs})

; --- Type Accessors ---

(defn fn-arg-types [t]
  (match t
    [{:fn args _} args]
    [_ (list)]))

(defn fn-ret-type [t]
  (match t
    [{:fn _ ret} ret]
    [_ :any]))

(defn list-elem-type [t]
  (match t
    [{:list elem} elem]
    [_ :any]))

(defn record-name [t]
  (match t
    [{:record name _} name]
    [_ :unknown]))

(defn record-fields [t]
  (match t
    [{:record _ fields} fields]
    [_ (list)]))

(defn sum-name [t]
  (match t
    [{:sum name _} name]
    [_ :unknown]))

(defn sum-variants [t]
  (match t
    [{:sum _ variants} variants]
    [_ (list)]))

(defn row-fields [t]
  (match t
    [{:row fields _} fields]
    [_ (list)]))

(defn row-tail [t]
  (match t
    [{:row _ tail} tail]
    [_ :closed]))

(defn tvar-id [t]
  (match t
    [{:tvar id} id]
    [_ -1]))

(defn rvar-id [t]
  (match t
    [{:rvar id} id]
    [_ -1]))

; --- Type Formatting (for error messages) ---
;
; We use 'a, 'b, 'c style for type variables (ML/Rust tradition).
; The key insight: raw IDs like {:tvar 452} are confusing.
; We normalize them contextually so errors show 'a, 'b instead.

; Simple format-type for backwards compatibility (uses raw IDs)
(defn format-type [t]
  (format-type-with-ctx t (maps/new)))

; Format with a normalization context (id -> display-index mapping)
(defn format-type-with-ctx [t ctx]
  (match t
    [:int "Int"]
    [:float "Float"]
    [:bool "Bool"]
    [:string "String"]
    [:any "Any"]
    [:unit "Unit"]
    [:ok "Ok"]
    [{:tvar id} (format-tvar-pretty (maps/get id ctx id))]
    [{:rvar id} (format-rvar-pretty (maps/get {:row id} ctx id))]
    [{:atom a} (erlang/iolist_to_binary (list ":" (erlang/atom_to_binary a)))]
    [{:list elem} (erlang/iolist_to_binary (list "List(" (format-type-with-ctx elem ctx) ")"))]
    [{:pid name _} (erlang/iolist_to_binary (list "Pid(" (erlang/atom_to_binary name) ")"))]
    [{:record name _} (erlang/atom_to_binary name)]
    [{:sum name _} (erlang/atom_to_binary name)]
    [{:fn args ret} (format-fn-type-ctx args ret ctx)]
    [{:row fields :closed} (format-closed-row-ctx fields ctx)]
    [{:row fields tail} (format-open-row-ctx fields tail ctx)]
    [_ "<unknown>"]))

; Convert normalized index to 'a, 'b, ... 'z, 'a1, 'b1, ...
(extern erlang/rem [:int :int] :int)
(extern erlang/div [:int :int] :int)

(defn format-tvar-pretty [idx]
  (let [base (erlang/rem idx 26)
        suffix-num (erlang/div idx 26)
        ; 97 = ASCII 'a'
        char-code (+ 97 base)
        base-char (char-to-string char-code)]
    (if (== suffix-num 0)
      (erlang/iolist_to_binary (list "'" base-char))
      (erlang/iolist_to_binary (list "'" base-char (erlang/integer_to_binary suffix-num))))))

(defn format-rvar-pretty [idx]
  (let [base (erlang/rem idx 26)
        suffix-num (erlang/div idx 26)
        char-code (+ 97 base)
        base-char (char-to-string char-code)]
    (if (== suffix-num 0)
      (erlang/iolist_to_binary (list ".." base-char))
      (erlang/iolist_to_binary (list ".." base-char (erlang/integer_to_binary suffix-num))))))

(extern erlang/list_to_binary [(List :int)] :string)
(defn char-to-string [code]
  (erlang/list_to_binary (list code)))

; --- Contextual Normalization ---
; Scan types to build a mapping: raw-id -> display-index (0, 1, 2...)
; This ensures errors show 'a, 'b instead of 't452, 't890

(extern lists/sort [(List :any)] (List :any))
(extern lists/usort [(List :any)] (List :any))
(extern lists/foldl [:any :any (List :any)] :any)

; Collect all type variable IDs from a type (in order of appearance)
(defn collect-tvars [t]
  (collect-tvars-acc t (list)))

(defn collect-tvars-acc [t acc]
  (match t
    [{:tvar id} (cons {:tvar id} acc)]
    [{:rvar id} (cons {:rvar id} acc)]
    [{:list elem} (collect-tvars-acc elem acc)]
    [{:fn args ret}
      (let [args-collected (lists/foldl (fn [arg a] (collect-tvars-acc arg a)) acc args)]
        (collect-tvars-acc ret args-collected))]
    [{:row fields tail}
      (let [fields-collected (lists/foldl
                               (fn [{_ ftype} a] (collect-tvars-acc ftype a))
                               acc
                               fields)]
        (collect-tvars-acc tail fields-collected))]
    [{:record _ fields}
      (lists/foldl (fn [{_ ftype} a] (collect-tvars-acc ftype a)) acc fields)]
    [{:sum _ variants}
      (lists/foldl
        (fn [{_ field-types} a]
          (lists/foldl (fn [ft a2] (collect-tvars-acc ft a2)) a field-types))
        acc
        variants)]
    [_ acc]))

; Build normalization context from multiple types (for error display)
; Returns a map: raw-id -> normalized-index
(defn build-display-ctx [types]
  (let [; Collect all tvars from all types
        all-vars (lists/foldl
                   (fn [t acc] (lists/append (collect-tvars t) acc))
                   (list)
                   types)
        ; Remove duplicates, keeping first occurrence order
        unique-vars (unique-ordered (lists/reverse all-vars))]
    ; Build map: var -> index
    (build-var-map unique-vars 0 (maps/new))))

(defn unique-ordered [lst]
  (unique-ordered-acc lst (sets/new) (list)))

(extern sets/new [] :any)
(extern sets/is_element [:any :any] :bool)
(extern sets/add_element [:any :any] :any)

(defn unique-ordered-acc [lst seen acc]
  (match lst
    [[] (lists/reverse acc)]
    [[v | rest]
      (if (sets/is_element v seen)
        (unique-ordered-acc rest seen acc)
        (unique-ordered-acc rest (sets/add_element v seen) (cons v acc)))]))

(defn build-var-map [vars idx acc]
  (match vars
    [[] acc]
    [[{:tvar id} | rest]
      (build-var-map rest (+ idx 1) (maps/put id idx acc))]
    [[{:rvar id} | rest]
      (build-var-map rest (+ idx 1) (maps/put {:row id} idx acc))]
    [[_ | rest]
      (build-var-map rest idx acc)]))

; --- Main API for Error Formatting ---
; Format types with automatic normalization (for error messages)

(defn format-types-for-error [expected actual]
  (let [ctx (build-display-ctx (list expected actual))]
    {:expected (format-type-with-ctx expected ctx)
     :actual (format-type-with-ctx actual ctx)}))

; Format a single type in context of others
(defn format-type-in-context [t context-types]
  (let [ctx (build-display-ctx (cons t context-types))]
    (format-type-with-ctx t ctx)))

; --- Context-aware formatting helpers ---

(defn format-fn-type-ctx [args ret ctx]
  (erlang/iolist_to_binary
    (list "(" (format-type-list-ctx args ctx) ") -> " (format-type-with-ctx ret ctx))))

(defn format-type-list-ctx [types ctx]
  (format-type-list-ctx-acc types ctx (list)))

(defn format-type-list-ctx-acc [types ctx acc]
  (match types
    [[] (join-with-comma (lists/reverse acc))]
    [[t | rest]
      (format-type-list-ctx-acc rest ctx (cons (format-type-with-ctx t ctx) acc))]))

(defn format-closed-row-ctx [fields ctx]
  (erlang/iolist_to_binary
    (list "{" (format-field-list-ctx fields ctx) "}")))

(defn format-open-row-ctx [fields tail ctx]
  (erlang/iolist_to_binary
    (list "{" (format-field-list-ctx fields ctx) " | " (format-type-with-ctx tail ctx) "}")))

(defn format-field-list-ctx [fields ctx]
  (format-field-list-ctx-acc fields ctx (list)))

(defn format-field-list-ctx-acc [fields ctx acc]
  (match fields
    [[] (join-with-comma (lists/reverse acc))]
    [[{name type} | rest]
      (let [formatted (erlang/iolist_to_binary
                        (list (erlang/atom_to_binary name) ": " (format-type-with-ctx type ctx)))]
        (format-field-list-ctx-acc rest ctx (cons formatted acc)))]))

; --- Legacy helpers (for backwards compat) ---

(defn format-fn-type [args ret]
  (format-fn-type-ctx args ret (maps/new)))

(defn format-type-list [types]
  (format-type-list-ctx types (maps/new)))

(defn join-with-comma [strs]
  (match strs
    [[] ""]
    [[s] s]
    [[s | rest]
      (erlang/iolist_to_binary (list s ", " (join-with-comma rest)))]))

(defn format-closed-row [fields]
  (format-closed-row-ctx fields (maps/new)))

(defn format-open-row [fields tail]
  (format-open-row-ctx fields tail (maps/new)))

(defn format-field-list [fields]
  (format-field-list-ctx fields (maps/new)))
