; Vaisto File I/O Module
; Provides file system operations for self-hosting preparation
;
; All file operations return Result types for error handling.

(ns Std.File)

; --- Erlang FFI ---

; Read entire file as binary/string
(extern file/read_file [:string] :any)

; Write binary/string to file
(extern file/write_file [:string :string] :any)

; Delete a file
(extern file/delete [:string] :any)

; Get file info
(extern filelib/is_regular [:string] :bool)
(extern filelib/is_dir [:string] :bool)
(extern filelib/file_size [:string] :int)

; Directory operations
(extern file/list_dir [:string] :any)
(extern file/make_dir [:string] :any)
(extern file/del_dir [:string] :any)

; Get current working directory
(extern file/get_cwd [] :any)

; --- High-Level API ---

; Read a file and return Result
; (read-file "path") -> (Ok "contents") | (Err reason)
(defn read-file [path]
  (from-erlang-result (file/read_file path)))

; Write contents to a file
; (write-file "path" "contents") -> (Ok :ok) | (Err reason)
(defn write-file [path contents]
  (from-erlang-result (file/write_file path contents)))

; Check if a path is a regular file
; (file? "path") -> true | false
(defn file? [path] :bool
  (filelib/is_regular path))

; Check if a path is a directory
; (dir? "path") -> true | false
(defn dir? [path] :bool
  (filelib/is_dir path))

; Get file size in bytes
; (file-size "path") -> Int
(defn file-size [path] :int
  (filelib/file_size path))

; List files in a directory
; (list-dir "path") -> (Ok [filenames]) | (Err reason)
(defn list-dir [path]
  (from-erlang-result (file/list_dir path)))

; Create a directory
; (mkdir "path") -> (Ok :ok) | (Err reason)
(defn mkdir [path]
  (from-erlang-result (file/make_dir path)))

; Delete a file
; (delete "path") -> (Ok :ok) | (Err reason)
(defn delete [path]
  (from-erlang-result (file/delete path)))

; Delete an empty directory
; (rmdir "path") -> (Ok :ok) | (Err reason)
(defn rmdir [path]
  (from-erlang-result (file/del_dir path)))

; Get current working directory
; (cwd) -> (Ok "path") | (Err reason)
(defn cwd []
  (from-erlang-result (file/get_cwd)))

; Check if a file exists (file or directory)
; (exists? "path") -> true | false
(defn exists? [path] :bool
  (if (file? path)
    true
    (dir? path)))

; --- Additional Operations ---

; Append to file (creates if doesn't exist)
(extern file/write_file [:string :string (List :atom)] :any)

; Append contents to a file
; (append "path" "contents") -> (Ok :ok) | (Err reason)
(defn append [path contents]
  (from-erlang-result (file/write_file path contents (list :append))))

; Copy a file
(extern file/copy [:string :string] :any)

; Copy a file to a new location
; (copy "src" "dest") -> (Ok bytes-copied) | (Err reason)
(defn copy [src dest]
  (from-erlang-result (file/copy src dest)))

; Rename/move a file
(extern file/rename [:string :string] :any)

; Rename or move a file
; (rename "old" "new") -> (Ok :ok) | (Err reason)
(defn rename [old-path new-path]
  (from-erlang-result (file/rename old-path new-path)))

; Alias for rename
(defn move [src dest]
  (rename src dest))

; Ensure directory exists (creates parent dirs if needed)
(extern filelib/ensure_dir [:string] :any)

; Create directory and all parent directories
; (mkdir-p "path/to/dir") -> (Ok :ok) | (Err reason)
; Note: ensure_dir expects a FILE path, creates parent dirs
(defn mkdir-p [path]
  ; Add trailing slash to treat as dir, then ensure parent exists
  (match (from-erlang-result (filelib/ensure_dir (path-join path ".")))
    [(Ok _) (mkdir path)]
    [(Err e) (Err e)]))

; --- Path Operations ---

(extern filename/join [(List :string)] :string)
(extern filename/dirname [:string] :string)
(extern filename/basename [:string] :string)
(extern filename/extension [:string] :string)
(extern filename/rootname [:string] :string)

; Join path segments
; (path-join "foo" "bar" "baz") -> "foo/bar/baz"
(defn path-join [a b]
  (filename/join (list a b)))

; Join list of path segments
; (path-join-all ["foo" "bar" "baz"]) -> "foo/bar/baz"
(defn path-join-all [parts]
  (filename/join parts))

; Get directory part of path
; (dirname "/foo/bar/baz.txt") -> "/foo/bar"
(defn dirname [path]
  (filename/dirname path))

; Get filename part of path
; (basename "/foo/bar/baz.txt") -> "baz.txt"
(defn basename [path]
  (filename/basename path))

; Get file extension (includes dot)
; (extension "/foo/bar.txt") -> ".txt"
(defn extension [path]
  (filename/extension path))

; Get path without extension
; (rootname "/foo/bar.txt") -> "/foo/bar"
(defn rootname [path]
  (filename/rootname path))

; --- Reading Variants ---

(extern binary/split [:string :string] (List :string))

; Read file as list of lines
; (read-lines "path") -> (Ok ["line1" "line2" ...]) | (Err reason)
(defn read-lines [path]
  (match (read-file path)
    [(Ok contents) (Ok (binary/split contents "\n"))]
    [(Err e) (Err e)]))

; --- Temporary Files ---

(extern filelib/safe_relative_path [:string :string] :any)

; Create a temp directory path (doesn't create the dir)
(extern filename/basedir [:atom :string] :string)

; Get system temp directory
(defn tmp-dir []
  "/tmp")

; Generate a unique temp file path
(extern erlang/unique_integer [] :int)
(extern erlang/integer_to_list [:int] (List :int))
(extern erlang/list_to_binary [(List :int)] :string)

(defn tmp-path [prefix]
  (let [unique (erlang/list_to_binary (erlang/integer_to_list (erlang/unique_integer)))]
    (path-join (tmp-dir) (str prefix unique))))
