; Std.String - String manipulation functions using Erlang's string/binary modules
(ns Std.String)

; Get string length (byte length)
(extern erlang/byte_size [:string] :int)

; Convert to uppercase
(extern string/uppercase [:string] :string)

; Convert to lowercase
(extern string/lowercase [:string] :string)

; Trim whitespace from both ends
(extern string/trim [:string] :string)

; Split string by delimiter
(extern string/split [:string :string] (List :string))

; Join list of strings with separator (note: Erlang uses lists:join)
(extern lists/join [:string (List :string)] (List :any))

; Get substring (start index, length)
(extern binary/part [:string :int :int] :string)

; Convert integer to string
(extern erlang/integer_to_binary [:int] :string)

; Higher-level helpers

; Get length of string
(defn length [s]
  (erlang/byte_size s))

; Check if string is empty
(defn empty? [s]
  (== (erlang/byte_size s) 0))

; Get a substring from start position with given length
(defn substring [s start len]
  (binary/part s start len))

; Repeat a string n times
(defn repeat [s n]
  (if (<= n 0)
    ""
    (let [half (/ n 2)
          doubled (repeat s half)]
      (if (== (* half 2) n)
        (concat doubled doubled)
        (concat s (concat doubled doubled))))))

; Simple concat using Erlang iolist
(extern erlang/iolist_to_binary [(List :any)] :string)

; Concatenate two strings
(defn concat [a b]
  (erlang/iolist_to_binary (list a b)))

; Convert integer to string
(defn from-int [n]
  (erlang/integer_to_binary n))

; --- Additional functions for self-hosting ---

; Get first character as integer codepoint (for parsing)
(extern binary/first [:string] :int)

; Get rest of string after first character
(extern binary/part [:string :int] :string)

; Get character at index as codepoint
(extern binary/at [:string :int] :int)

; Check if string starts with prefix
(extern string/prefix [:string :string] :any)

; Check if string contains substring
(extern string/find [:string :string] :any)

; Replace all occurrences
(extern string/replace [:string :string :string] :string)

; Get first byte/character (returns codepoint)
(defn first-char [s]
  (binary/first s))

; Get rest of string after first byte
(defn rest [s]
  (binary/part s 1))

; Check if string starts with given prefix
(defn starts-with? [s prefix]
  (match (string/prefix s prefix)
    [:nomatch false]
    [_ true]))

; Check if string contains substring
(defn contains? [s needle]
  (match (string/find s needle)
    [:nomatch false]
    [_ true]))

; --- Trim variants ---

; Trim with direction (Erlang FFI)
(extern string/trim [:string :atom] :string)

; Trim whitespace from start of string
(defn trim-leading [s]
  (string/trim s :leading))

; Trim whitespace from end of string
(defn trim-trailing [s]
  (string/trim s :trailing))

; --- Case detection ---

; Check if string is all uppercase
(defn upper? [s]
  (== s (string/uppercase s)))

; Check if string is all lowercase
(defn lower? [s]
  (== s (string/lowercase s)))

; Check if character (codepoint) is uppercase letter
(defn char-upper? [c]
  (if (< c 65)
    false
    (if (> c 90)
      false
      true)))

; Check if character (codepoint) is lowercase letter
(defn char-lower? [c]
  (if (< c 97)
    false
    (if (> c 122)
      false
      true)))

; Check if character (codepoint) is a digit
(defn char-digit? [c]
  (if (< c 48)
    false
    (if (> c 57)
      false
      true)))

; Check if character (codepoint) is whitespace
(defn char-whitespace? [c]
  (if (== c 32) true     ; space
    (if (== c 9) true    ; tab
      (if (== c 10) true ; newline
        (if (== c 13) true ; carriage return
          false)))))
